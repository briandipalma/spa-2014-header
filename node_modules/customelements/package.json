{
  "name": "customelements",
  "description": "Polyfill for W3C CustomElements Specification",
  "version": "0.0.7",
  "devDependencies": {
    "mocha": "*",
    "chai": "*",
    "grunt": "*",
    "grunt-contrib-uglify": "*",
    "grunt-contrib-yuidoc": "~0.4.0",
    "grunt-karma": "*",
    "karma-mocha": "*",
    "karma-ie-launcher": "*",
    "karma-safari-launcher": "*",
    "karma-script-launcher": "*",
    "karma-crbot-reporter": "*"
  },
  "contributors": [
    {
      "name": "Google Inc.",
      "email": "*@google.com"
    }
  ],
  "readme": "## Learn the tech\n\n### Why Custom Elements?\n\nCustom Elements let authors define their own elements. Authors associate JavaScript code with custom tag names, and then use those custom tag names as they would any standard tag.\n\nFor example, after registering a special kind of button called `super-button`, use the super button just like this:\n\n    <super-button></super-button>\n\nCustom elements are still elements. We can create, use, manipulate, and compose them just as easily as any standard `<div>` or `<span>` today.\n\n### Basic usage\n\nAs with any element, custom elements can be created in JavaScript or declared. **Custom element names must always contain a dash (-).**\n\n#### Element registration\n\nBefore you can use a custom element, it needs to be registered. Otherwise, the browser considers it an `HTMLElement`.\n\n##### document.registerElement()\n\nTo register a new custom element in JavaScript, invoke `document.registerElement()` somewhere in the page.\nAs before, custom elements built this way work just like standard elements.\n\nHere's the imperative version of the previous example:\n\n    var XFooPrototype = Object.create(HTMLElement.prototype);\n    XFooPrototype.createdCallback = function() {\n      this.textContent = \"I'm an x-foo!\";\n    };\n    XFooPrototype.foo = function() {\n      console.log('foo() called');\n    };\n\n    var XFoo = document.registerElement('x-foo', {\n      prototype: XFooPrototype\n    });\n\n**Note:** the prototype must be chained to `HTMLElement.prototype` (i.e. `instanceof HTMLElement.prototype`).\n\n**Extending existing elements**\n\nIf you want to inherit from a specialized form of `HTMLElement` (e.g. `HTMLButtonElement`),\ndeclare the type using the `extends` option when calling `document.registerElement()`:\n  \nExample extending `button`:\n  \n    var XFooButtonPrototype = Object.create(HTMLButtonElement.prototype);\n    XFooButtonPrototype.createdCallback = function() {\n      this.textContent = \"I'm an x-foo button!\";\n    };\n\n    var XFooButton = document.registerElement('x-foo-button', {\n      prototype: XFooButtonPrototype,\n      extends: 'button'\n    });\n\n#### Using a custom element\n\nAfter registration, you can construct an instance of your element just like\nstandard DOM elements:\n\n    <x-foo></x-foo>\n\nIf you've used `extends` to create a custom element that derives from an existing DOM element\n(e.g. something other than `HTMLElement`), use the `is` syntax:\n\n    <button is=\"x-foo-button\"></button>\n\nIn the declarative and `document.registerElement()` example above, `XFoo` was defined as the new element's constructor.\nThis can also be used to create an instance:\n\n    var xFoo = new XFoo();\n    document.body.appendChild(xFoo);\n\n    var xFooButton = document.createElement('button', 'x-foo-button');\n    xFooButton.foo(); // \"foo() called\"\n\nBrowser limitations require that we supply the constructor while you supply the `prototype`.\nUse the `createdCallback` to do initialization work that might otherwise be in a constructor.\n\n## Polyfill details\n\n### Getting Started\n\nInclude the `custom-elements.js` or `custom-elements.min.js` (minified) file in your project.\n\n    <script src=\"CustomElements/custom-elements.js\"></script>\n\n`custom-elements.js` is the debug loader and uses `document.write` to load additional modules. \nUse the minified version (`custom-elements.min.js`) if you need to load the file dynamically.\n\n### Polyfill Notes\n\nThe custom elements polyfill handles element upgrades _asynchronously_. The polyfill defers upgrading elements until `DOMContentsLoaded` time. It does this as a performance optimization. Subsequent to the initial upgrade pass, Mutation Observers are used to discover new elements.\n\nTo know when the polyfill has finished all of its start up tasks, listen to the `WebComponentsReady` event on `document` or `window`.\n\nExample:\n\n    <script>\n      // hide body to prevent FOUC\n      document.body.style.opacity = 0;\n      window.addEventListener('WebComponentsReady', function() {\n        // show body now that everything is ready\n        document.body.style.opacity = 1;\n      });\n    </script>\n\nThe Custom Elements specification is still under discussion. The polyfill implements certain features in advance of the specification. In particular, the lifecycle callback methods that get called if implemented on the element prototype:\n\n* `createdCallback()` is called when a custom element is created.\n* `attachedCallback()` is called when a custom element is inserted into a DOM subtree.\n* `detachedCallback()` is called when a custom element is removed from a DOM subtree.\n* `attributeChangedCallback(attributeName)` is called when a custom element's attribute value has changed\n\n`createdCallback` is invoked _synchronously_ with element instantiation, the other callbacks are called _asyncronously_. The asynchronous callbacks generally use the MutationObserver timing model, which means they are called before layouts, paints, or other triggered events, so the developer need not worry about flashing content or other bad things happening before the callback has a chance to react to changes.\n\n## Tools & Testing\n\nFor running tests or building minified files, consult the [tooling information](http://polymer-project.org/resources/tooling-strategy.html).\n",
  "readmeFilename": "README.md",
  "_id": "customelements@0.0.7",
  "_from": "customelements@0.0.7"
}
